---
layout: single
title:  "Java로 주소록 구현하기"
categories: Java
tag: [Java, 주소록, 프로젝트]
author_profile: false
toc: true
---

# Java로 주소록 구현하기 - 1
<br>
예전에 C언어와 C++로 구현했던 주소록을 Java로 구현해보려고 합니다.<br><br>
C에서는 콘솔로 먼저 메인테스트를 작성한 후 WIN32 API로 GUI구성 후 디스크파일로 연동했고,<br><br>
C++에서 역시 콘솔로 먼저 메인테스트를 작성한 후에 MFC로 GUI 구성 후 MySQL연동까지하였는데,<br><br>
자바에서는 Swing으로 GUI를 구성해서 MySQL까지 연동을 시켜야 할 지 말지...
MFC도 질리도록 했는데 Swing을 다시 배우자니 고민되네요ㅠ<br><br>
그래서 일단은 java로 콘솔까지는 옮겨보려고 합니다.<br><br>

# Persnoal 클래스 생성하기
## 필드
주소록에서 개인의 정보를 저장하기 위해 Personal 클래스를 생성합니다.<br><br>
인스턴스 멤버 중에 필드는 이름, 주소, 전호번호, 이메일주소로 정합니다.<br><br>
이때 각 필드는 외부에서 그 값을 함부로 바꿀 수 없도록 private으로 설정합니다.

```java
    //인스턴스 멤버(필드)
    private String name;
    private String address;
    private String telephoneNumber;
    private String emailAddress;
```
## getter 메소드
그리고 필드가 private이면 외부에서 값을 접근도 할 수 없기 때문에 값을 읽기 위해서는 public getter 메소드들이 필요합니다.

```java
    //이름 정보 가져오기
    public String getName()
    {
        return this.name;
    }
    //주소 정보 가져오기
    public String getAddress()
    {
        return this.address;
    }
    //전화번호 정보 가져오기
    public String getTelephoneNumber()
    {
        return this.telephoneNumber;
    }
    //이메일 정보 가져오기
    public String getEmailAddress()
    {
        return this.emailAddress;
    }
```
## 생성자
생성자는 매개변수없는 디폴트생성자, 필드들에 대입할 값들을 매개변수로 받는 생성자와 매개변수로 입력받은 Personal객체를 복사해주는 복사생성자를 정의합니다.<br><br>
Personal의 경우 모든 필드가 String이기 때문에 Personal의 복사생성자의 경우 그냥 source(Personal)의 모든 필드를 대입합니다.<br><br>
그래도 상관없는 이유는 자바에서 String은 객체의 문자열 값을 변경하면 새로운 객체를 생성하기 때문입니다.
### String의 특성
이말이 무슨 말이냐면, 예를 들어, one(Persoanl)이라는 객체가 복사생성자를 이용해서 source(Personal)의 모든 필드를 그대로 대입해서 저장하고 난 후에<br><br>
source의 모든 String필드들의 문자열 값을 변경하면 변경한 문자열을 바탕으로 String의 새로운 객체들이 생성되고<br><br>
기존에 문자열들은 one의 String필드들이 가지고 있기 때문에 이런식으로 대입만해도 깊은 복사가 됩니다.<br><br>
다시 말하지만 이는 Java에서 String객체의 특성으로 인해
이럭식으로 대입을 해도 깊은 복사가 가능합니다.<br><br>
다른 객체의 경우 이런식으로 대입만해서 복사를 하면 **'얕은 복사'**라서 원본의 값을 수정하면 복사본의 값도 수정되기 때문에 진정한 의미에서 복사라고 보기는 힘듭니다.

```java
    //디폴트 생성자
    public Personal()
    {
        this.name = "";
        this.address = "";
        this.telephoneNumber = "";
        this.emailAddress = "";
    }
    //매개변수를 가지는 생성자
    public Personal(String name, String address,
     String telephoneNumber, String emailAddress)
    {
        this.name = name;
        this.address = address;
        this.telephoneNumber = telephoneNumber;
        this.emailAddress = emailAddress;
    }
    //복사생성자
    public Personal(Personal source)
    {
        this.name = source.name;
        this.address = source.address;
        this.telephoneNumber = source.telephoneNumber;
        this.emailAddress = source.emailAddress;
    }
```
## 기타 메소드
메소드로는 Personal 객체가 같은지 다른지를 필드들의 정보로 비교하는 isEqual, isNotEqual을 정의합니다. 

```java
 //같은 Personal 객체인지 확인하기
    public boolean isEqual(Personal other)
    {
        boolean ret = false;
        if(this.name.compareTo(other.name)==0 || this.address.compareTo(other.address)==0
                || this.telephoneNumber.compareTo(other.telephoneNumber)==0
                || this.emailAddress.compareTo(other.emailAddress)==0)
        {
            ret = true;
        }
        return ret;
    }
    //다른 Personal 객체인지 확인하기
    public boolean isNotEqual(Personal other)
    {
         boolean ret = false;
         if(this.name.compareTo(other.name)!=0 && this.address.compareTo(other.address)!=0
                 && this.telephoneNumber.compareTo(other.telephoneNumber)!=0
                 && this.emailAddress.compareTo(other.emailAddress)!=0)
         {
             ret = true;
         }
         return  ret;
    }
```
## clone 메소드 구현하기
또한 자바에서는 복사생성자를 사용하기보다는 Cloneable 인터페이스를 구현하여 clone메소드를 사용하는 것 같아서 Personal이 Cloneable인터페이스를 구현하여 clone메소드를 오버라이딩하여 이용해보도록 하겠습니다.
### Cloneable 인터페이스
Cloneable 인터페이스는 내부에 추상메소드를 포함하고 있지 않고, 단순히 Cloneable인터페이스를 구현하는 클래스는 복사기능이 있다는 것을 표시하는 용도의 인터페이스입니다.<br><br>
모든 클래스의 부모 클래스인 최상위 부모클래스 Object는 clone메소드를 가지고 있습니다. clone메소드를 호출하면 자신의 객체를 복사해서 이를 리턴합니다.<br><br> 다만 이를 사용하기 위해서는 clone을 사용하려는 클래스는 반드시 Cloneable 클래스를 구현하여야 합니다. 그렇지 않으면 CloneNotSupportedException이 발생합니다.<br><br> 그래서 Object의 clone메소드를 이용하고 싶은 클래스는 Cloneable 인터페이스를 implements해야 합니다.
### Object의 clone메소드
Object의 clone메소드의 접근제어자가 protected이기 때문에 외부에서는 접근을 할 수 없습니다. 그래서 clone을 구현하는 클래스는 추가 기능이 없더라도 반드시 이를 오버라이딩해서 내부에서 Object의 clone메소드를 구현해서 사용해야합니다.<br><br>
이 때 Personal이 clone을 오버라이딩할 때 접근제어자를 public으로 한 이유는 자손이 부모의 클래스(여기서 부모 클래스는 Object이고 Object의 clone의 접근제어자가 protected이기 때문에)를 오버라이딩할 때 접근제어가 최소 같거나 그것보다 넓어야 하기 때문입니다.(private < default < protected < public)<br><br>
Personal의 clone메소드에서 super는 Object를 의미합니다. Personal이 따로 상속받은 클래스가 없기 때문에 자동으로 Object를 상속합니다.<br><br>
따라서 아래의 코드는 내부적으로 그냥 object의 clone메소드를 호출하고, Personal으로 형변환을 한 뒤에 반환하는 코드입니다. 이렇게 해도 깊은 복사가 되는 이유는 앞에서 말했듯이 Personal의 필드멤버들이 모두 String이기 때문입니다.
```java
    //Cloneable인터페이스의 clone 메소드 오버라이딩하기(구현하기)
    @Override
    public Personal clone() throws CloneNotSupportedException
    {
        return (Personal)super.clone();
    }
```
## 전체코드
다음으로는 전체 코드를 첨부합니다.

```java
package AddressBook;

public class Personal implements Cloneable
{
    //디폴트 생성자
    public Personal()
    {
        this.name = "";
        this.address = "";
        this.telephoneNumber = "";
        this.emailAddress = "";
    }
    //매개변수를 가지는 생성자
    public Personal(String name, String address,
     String telephoneNumber, String emailAddress)
    {
        this.name = name;
        this.address = address;
        this.telephoneNumber = telephoneNumber;
        this.emailAddress = emailAddress;
    }
    //복사생성자
    public Personal(Personal source)
    {
        this.name = source.name;
        this.address = source.address;
        this.telephoneNumber = source.telephoneNumber;
        this.emailAddress = source.emailAddress;
    }
    //같은 Personal 객체인지 확인하기
    public boolean isEqual(Personal other)
    {
        boolean ret = false;
        if(this.name.compareTo(other.name)==0
                && this.address.compareTo(other.address)==0
                && this.telephoneNumber.compareTo(other.telephoneNumber)==0
                && this.emailAddress.compareTo(other.emailAddress)==0)
        {
            ret = true;
        }
        return ret;
    }
    //다른 Personal 객체인지 확인하기
    public boolean isNotEqual(Personal other)
    {
         boolean ret = false;
         if(this.name.compareTo(other.name)!=0
                 || this.address.compareTo(other.address)!=0
                 || this.telephoneNumber.compareTo(other.telephoneNumber)!=0
                 || this.emailAddress.compareTo(other.emailAddress)!=0)
         {
             ret = true;
         }
         return  ret;
    }
    //Cloneable 의 clone 메소드 오버라이딩하기(구현하기)
    @Override
    public Personal clone() throws CloneNotSupportedException
    {
        return (Personal)super.clone();
    }

    //이름 정보 가져오기
    public String getName()
    {
        return this.name;
    }
    //주소 정보 가져오기
    public String getAddress()
    {
        return this.address;
    }
    //전화번호 정보 가져오기
    public String getTelephoneNumber()
    {
        return this.telephoneNumber;
    }
    //이메일 정보 가져오기
    public String getEmailAddress()
    {
        return this.emailAddress;
    }
    //이름은 수정할 수 없기 때문에 따로 setter 를 만들지 않음.
    //주소 정보 수정하기
    public void setAddress(String address)
    {
        this.address = address;
    }
    //전화번호 정보 수정하기
    public void setTelephoneNumber(String telephoneNumber)
    {
        this.telephoneNumber = telephoneNumber;
    }
    //이메일주소 정보 수정하기
    public void setEmailAddress(String emailAddress)
    {
        this.emailAddress = emailAddress;
    }
    //인스턴스 필드
    private String name;
    private String address;
    private String telephoneNumber;
    private String emailAddress;
}

```
