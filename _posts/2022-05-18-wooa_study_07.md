---
layout: single
title: "헥사고날-아키텍쳐로-구현하는-작은-스프링-부트-토이-프로젝트-우아한스터디-07"
categories: Java
tag: [Java, 우아한스터디, 만들면서 배우는 클린 아키텍쳐, 7장]
toc: true
toc_label: "목차"
toc_sticky: true
---

# 만들면서 배우는 클린 아키텍쳐 7장 정리
# 아키텍처 요소 테스트하기
이번 장에서는 육각형 아키텍처에서의 테스트 전략과 아키텍처의 각 요소들을 테스트할 수 있는 테스트 유형에 대해 이야기합니다.  

## 테스트 유형
책에서는 육각형 아키텍처를 테스트 하기 위해 단위 테스트, 통합 테스트, 시스템 테스트이라는 용어를 사용하는데 이에 대한 정의는 맥락에 따라 다르며, 프로젝트마다 다른 의미를 가질 수 있습니다.  

## 테스트 피라미드
또한 맥락에 따라 테스트 피라미드에 포함되는 계층 역시 달라질 수 있습니다. 

테스트 피라미드에 따르면 비용이 많이 드는 테스트는 지양하고, 비용이 적게 드는 테스트를 많이 만들어야 합니다.  

테스트 피라미드에는 제일 밑에 층에 단위 테스트, 중간에 통합 테스트, 제일 상단에 시스템 테스트가 위치하며 밑에 층일수록 비용이 적게 들고 위에 층일수록 비용이 많이 듭니다.

피라미드의 위에 위치한 테스트는 일반적으로 여러 개의 단위와 단위를 넘는 경계, 아키텍처 경계, 시스템의 경계를 결합하는 테스트는 만드는 비용이 비싸며 실행이 더 느려지고, 기능 에러보다 설정 에러로 인해 깨지기 더 쉽습니다.  

이렇게 테스트가 비싸질수록 테스트의 커버리지 목표는 낮게 잡아야 합니다.  

그렇지 않으면 새로운 기능을 만드는 것보다 테스트를 만드는 데 시간을 더 사용하기 때문입니다.  

### 단위 테스트
테스트 피라미드의 가장 아래에 위치하여 토대에 해당하는 단위 테스트는 하나의 단위(일반적으로 하나의 클래스)가 제대로 동작하는지 확인할 수 있는 테스트입니다.  

이러한 단위 테스트는 만드는 비용이 적고, 유지보수하기 쉽고, 빨리 실행되고, 안정적인 작은 크기의 테스트들에 대해 높은 커버리지를 유지할 수 있습니다.  

일반적으로 하나의 클래스를 인스턴스화하고 해당 클래스의 인터페이스를 통해 기능들을 테스트 합니다.  

만약 테스트 중인 클래스가 다른 클래스에 의존한다면 테스트 중인 클래스에서 의존하는 클래스를 직접 인스턴스화하지 않고, 테스트하는 동안 필요한 작업을 흉내 내는 목(mock)으로 대체합니다.  

### 통합 테스트
테스트 피라미드에서 단위 테스트의 다음 계층은 통합테스트입니다.  

이 테스트는 연결된 여러 유닛을 인스턴스화하고 시작점이 되는 클래스의 인터페이스로 데이터를 보낸 후 유닛들의 네트워크가 기대한대로 잘 동작하는지 검증합니다.  

상황에 따라서 두 계층 간의 경계를 걸쳐서도 테스트 할 수 있기 때문에 객체 네트워크가 완전하지 않을 수 있고, 어떤 시점에는 목(mock)을 대상으로 수행해야 합니다.  

### 시스템 테스트
애플리케이션을 구성하는 모든 객체 네트워크를 가동시켜 특정 유스케이스가 전 계층에서 잘 동작하는지 검증합니다.  

### 엔드투엔드(end-to-end) 테스트
시스템 테스트 위에 위치하는 테스트로써 시스템 테스트에서 했던 것과 더불어 애플리케이션의 UI를 포함해 테스트합니다.

## 단위 테스트로 도메인 엔티티 테스트하기
육각형 아키텍처의 중심인 도메인 엔티티를 테스트하기 위해서는 단위 테스트가 적합합니다.  

책에서 사례로 제시한 Account 엔티티의 상태는 과거 특정 시점의 계좌 잔고(baselineBalance)와 그 이후의 입출금 내역(activity)로 구성되어 있습니다.  

이 Account 엔티티의 메소드 중 하나인 withdraw 메서드의 테스트 코드는 아래와 같습니다.  

```java
class AccountTest {
    @Test
    void withdrawalSucceeds() {
        AccountId accountId = new AccountId(1L);
		Account account = defaultAccount()
				.withAccountId(accountId)
				.withBaselineBalance(Money.of(555L))
				.withActivityWindow(new ActivityWindow(
						defaultActivity()
								.withTargetAccount(accountId)
								.withMoney(Money.of(999L)).build(),
						defaultActivity()
								.withTargetAccount(accountId)
								.withMoney(Money.of(1L)).build()))
				.build();

		boolean success = account.withdraw(Money.of(555L), new AccountId(99L));

		assertThat(success).isTrue();
		assertThat(account.getActivityWindow().getActivities()).hasSize(3);
		assertThat(account.calculateBalance()).isEqualTo(Money.of(1000L));
    }
}
```

위 코드는 특정 상태의 Account를 인스턴스화하고(given), withdraw 메서드를 호출(when)해서 출금이 성공했는지 boolean반환값을 통해 확인하고(then), Account 객체의 상태에 대해 기대되는 부수효과들이 잘 일어났는지 확인하는(then) 단순한 단위 테스트입니다.  

위와 같은 테스트는 만들고 이해하기 쉽고, 아주 빠르게 실행됩니다.  

도메인 엔티티의 행동은 다른 클래스에 거의 의존하지 않기 때문에 다른 종류의 테스트는 필요없으며 단위 테스트야말로 도메인 엔티티에 녹아 있는 비즈니스 규칙을 검증하기 가장 적절한 방법입니다.  

## 단위 테스트로 유스케이스 테스트하기
이제 육각형 아키텍처에서 도메인 엔티티 클래스에 대한 테스트를 마쳤으니 계층의 바깥쪽에 위치한 유스케이스를 테스트할 차례입니다.  

책에서는 SendMoneyService를 테스트 예시로 제시합니다.  

SendMoney 유스케이스는 출금 계좌 잔고가 다른 트랜잭션에 의해 변경도지 않도록 락(lock)을 겁니다.  

출금 계좌에서 돈이 출금되고 나면 똑같이 입금 계좌에 락을 걸고 돈을 입금시킵니다.  

이 과정이 끝나면 두 계좌에서 모두 락을 해제합니다.  

아래의 테스트 코드에서 트랜잭션이 성공했을 때 유스케이스대로 잘 동작하는지 테스트합니다.  

```java
class SendMoneyServiceTest {

    //필드 선언은 생략

    @Test
	void transactionSucceeds() {

		Account sourceAccount = givenSourceAccount();
		Account targetAccount = givenTargetAccount();

		givenWithdrawalWillSucceed(sourceAccount);
		givenDepositWillSucceed(targetAccount);

		Money money = Money.of(500L);

		SendMoneyCommand command = new SendMoneyCommand(
				sourceAccount.getId().get(),
				targetAccount.getId().get(),
				money);

		boolean success = sendMoneyService.sendMoney(command);

		assertThat(success).isTrue();

		AccountId sourceAccountId = sourceAccount.getId().get();
		AccountId targetAccountId = targetAccount.getId().get();

		then(accountLock).should().lockAccount(eq(sourceAccountId));
		then(sourceAccount).should().withdraw(eq(money), eq(targetAccountId));
		then(accountLock).should().releaseAccount(eq(sourceAccountId));

		then(accountLock).should().lockAccount(eq(targetAccountId));
		then(targetAccount).should().deposit(eq(money), eq(sourceAccountId));
		then(accountLock).should().releaseAccount(eq(targetAccountId));

		thenAccountsHaveBeenUpdated(sourceAccountId, targetAccountId);
	}

    //헬퍼 메서드는 생략
}
```

테스트 가독성을 높이기 위해 행동-주도 개발(behavior driven development)에서 일반적으로 사용하는 방식인 given/when/then을 사용합니다.  

### given
given에서 출금(source) 및 입금(target) Account의 인스턴스(sourceAccount, targetAccount)를 각각 생성하고, 적절한 상태로 만듭니다.(givenSourceAccount와 givenTargetAccount 메서드 호출)  

그 다음으로 이렇게 초기화 된 Account들의 인스턴스를 각각 givenWithdrawalWillSucceed와 givenDepositWillSucced 메소드의 매개변수로 넣습니다.  

입력 모델인 SendMoneyCommand 인스턴스를 생성하면서 출금과 입금의 Account 인스턴스를 매개변수로 넣어주는데 이를 통해 SendMoneyUsecase의 입력 유효성을 검증합니다.  

### when
when에서는 SendMoenyService의 sendMoney 메서드를 호출하면서 입력 유효성 검증이 끝난 SendMoneyCommand 인스턴스를 매개변수로 넣어줍니다.  

### then
then에서는 sendMoney의 반환값인 boolean이 true인지 확인하여 성공적으로 송금이 이루어졌는지 검증합니다.  

그리고 츨금 및 밉금 Account, 계좌에 락을 걸고 해제하는 책임을 가진 AccountLock에 대해 특정 메서드가 호출되었는지를 확인합니다.  

### Mockito 이용
SendMoneyServiceTest의 givenWithdrawalWillSucceed와 givenDepositWillSucceed 메서드는 Mockito 라이브러리 given을 이용해 목(mock)객체를 생성합니다.  

```java
class SendMoneyServiceTest {

    //생략

    private void givenWithdrawalWillSucceed(Account account) {
		given(account.withdraw(any(Money.class), any(AccountId.class)))
				.willReturn(true);
	}

    private void givenDepositWillSucceed(Account account) {
		given(account.deposit(any(Money.class), any(AccountId.class)))
				.willReturn(true);
	}

    //생략

}
```

또한 아까 transactionSucceeds 코드에서 출금 및 입급 Account와 계좌에 락을 걸고 해제하는 책임을 가진 AccountLock에 대해 특정 메서드가 호출되었는지 검증하기 위해 사용한 것이 바로 Mockito 라이브러리의 then입니다.  

### 유의사항
테스트 중인 유스케이스 서비스는 stateless(무상태)이기 때문에 'then'에서 특정 상태를 검증할 수 없습니다.  

즉, 도메인 엔티티인 Account 인스턴스에 무슨 값이 저장되어 있고, 무슨 값이 저장되야 맞고 틀린지를 확인할 수 없다는 말입니다.  

대신에 유스케이스 서비스 테스트에서는  Mockito 라이브러리 given을 이용해 생성된 목(mock)객체, 즉, 서비스가 의존하는 대상의 특정 매서드와 상호작용했는지 여부를 검증합니다.  

**이렇게 되면 테스트는 코드의 행동 변경뿐만 아니라 코드의 구조 변경에도 취약해집니다?(무슨 말인지 아직 이해못함)**

이 상황에서는 코드가 리팩터링되면 테스트도 변경해야할 확률이 높아집니다.  

그래서 테스트에서 어떤 상호작용을 검증하고 싶은지 신중하게 생각해야 합니다.  

따라서 앞에서 주어진 transactionSucceeds 테스트 코드처럼 **모든** 동작을 검증하는 것이 아니라 중요한 핵심 부분만 골라 집중해서 테스트하는 것이 바람직합니다.  

왜냐하면 모든 동작을 검증하려고 하면 클래스가 조금이라도 바뀔 때마다 테스트를 계속 변경해야 해서 테스트의 가치가 떨어지기 때문입니다.  

### 단위 테스트? or 통합 테스트? 
유스케이스의 테스트는 단위 테스트로 분류하였지만 의존성의 상호작용을 테스트 하고 있기 때문에 통합 테스트에 더 가깝습니다.  

하지만 실제 의존성을 관리하지 않고, Mockito 라이브러리를 사용해 목(mock)으로 작업하고 있기 때문에 완전한 통합 테스트에 비해서는 만들고 유지보수하기 쉽습니다.  

